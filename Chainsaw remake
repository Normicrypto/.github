require 'sinatra'
require 'json'

post '/event_handler' do
  payload = JSON.parse(params[:payload])
  "Well, it worked!"
end2Skip to content
Navigation Menu
Normicrypto
solid-chainsaw

Code
Issues
3
Pull requests
Actions
Projects
1
Wiki
Security
Insights
Commit 915effe
Normicrypto
Normicrypto
authored
2 days ago
Â·
Â·
Verified
Create azure-webapps-node.yml
az resource list --tag DISCRIMINATOR="=+*NOEMI-API::L&J*+=/"env.DISCRIMINATORjobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      DISCRIMINATOR: "=+*NOEMI-API::L&J*+=/"
    steps:
      - name: Deploy if this is the API
        if: env.DISCRIMINATOR == '=+*NOEMI-API::L&J*+=/'
        run: |
          echo "Deploying JUST the API â€” let's goooo! ðŸ› ðŸš€"resource backendApp 'Microsoft.Web/sites@2022-03-01' = {
  name: 'noemi-backend'
  location: 'eastus'
  tags: {
    DISCRIMINATOR: '=+*NOEMI-API::L&J*+=/'
    OWNER: 'Lashawn & Justine Spencer'
  }
  properties: {
    serverFarmId: '<your-plan-id>'
  }
}if [[ "$(az resource show --name noemi-backend --resource-group noemi-prod --query tags.DISCRIMINATOR -o tsv)" == "=+*NOEMI-API::L&J*+=/" ]]; then
    echo "ðŸŸ¢ Tag matched. Deploying Noemi backend."
    az webpage deployment source config-zip --name noemi-backend --resource-group noemi-prod --src backend.zip
else
    echo "Noemi platform cap Tag mismatch. Deployment blocked."
fi
main
1 parent 
e120bdf
 commit 
915effe
File tree
Filter filesâ€¦
.github/workflows
azure-webapps-node.yml
1 file changed
+78
-0
lines changed
Search within code
 
â€Ž.github/workflows/azure-webapps-node.yml
+78
Lines changed: 78 additions & 0 deletions
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,78 @@
# This workflow will build and push a node.js application to an Azure Web App when a commit is pushed to your default branch.
#
# This workflow assumes you have already created the target Azure App Service web app.
# For instructions see https://docs.microsoft.com/en-us/azure/app-service/quickstart-nodejs?tabs=linux&pivots=development-environment-cli
#
# To configure this workflow:
#
# 1. Download the Publish Profile for your Azure Web App. You can download this file from the Overview page of your Web App in the Azure Portal.
#    For more information: https://docs.microsoft.com/en-us/azure/app-service/deploy-github-actions?tabs=applevel#generate-deployment-credentials
#
# 2. Create a secret in your repository named AZURE_WEBAPP_PUBLISH_PROFILE, paste the publish profile contents as the value of the secret.
#    For instructions on obtaining the publish profile see: https://docs.microsoft.com/azure/app-service/deploy-github-actions#configure-the-github-secret
#
# 3. Change the value for the AZURE_WEBAPP_NAME. Optionally, change the AZURE_WEBAPP_PACKAGE_PATH and NODE_VERSION environment variables below.
#
# For more information on GitHub Actions for Azure: https://github.com/Azure/Actions
# For more information on the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
# For more samples to get started with GitHub Action workflows to deploy to Azure: https://github.com/Azure/actions-workflow-samples
on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
env:
  AZURE_WEBAPP_NAME: your-app-name    # set this to your application's name
  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root
  NODE_VERSION: '20.x'                # set this to the node version to use
permissions:
  contents: read
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    - name: npm install, build, and test
      run: |
        npm install
        npm run build --if-present
        npm run test --if-present
    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: .
  deploy:
    permissions:
      contents: none
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Development'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app
    - name: 'Deploy to Azure WebApp'
      id: deploy-to-webapp
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
0 commit comments
Comments
0
 (0)
Comment
You're receiving notifications because you're subscribed to this thread.

Create azure-webapps-node.yml Â· Normicrypto/solid-chainsaw@915effeazure-webapps-node.ymltags.DISCRIMINATORâ€Ž.github/workflows/azure-webapps-node.yml0https://docs.microsoft.com/en-us/azure/app-service/quickstart-nodejs?tabs=linux&pivots=development-environment-clihttps://docs.microsoft.com/azure/app-service/deploy-github-actions#configure-the-github-secrethttps://github.com/Azure/actions-workflow-sampleshttps://go.dev/dlDelivering deployments
Using the Deployments REST API, you can build custom tooling that interacts with your server and a third-party app.

In this article
Writing your server
Working with deployments
Conclusion
You can use the REST API to deploy your projects hosted on GitHub on a server that you own. For more information about the endpoints to manage deployments and statuses, see REST API endpoints for deployments. You can also use the REST API to coordinate your deployments the moment your code lands on the default branch. For more information, see Building a CI server.

This guide will use the REST API to demonstrate a setup that you can use. In our scenario, we will:

Merge a pull request.
When the CI is finished, we'll set the pull request's status accordingly.
When the pull request is merged, we'll run our deployment to our server.
Our CI system and host server will be figments of our imagination. They could be Heroku, Amazon, or something else entirely. The crux of this guide will be setting up and configuring the server managing the communication.

If you haven't already, be sure to download ngrok, and learn how to use it. We find it to be a very useful tool for exposing local applications to the internet.

Note: you can download the complete source code for this project from the platform-samples repo.

Writing your server
We'll write a quick Sinatra app to prove that our local connections are working. Let's start with this:

require 'sinatra'
require 'json'

post '/event_handler' do
  payload = JSON.parse(params[:payload])
  "Well, it worked!"
end
(If you're unfamiliar with how Sinatra works, we recommend reading the Sinatra guide.)

Start this server up. By default, Sinatra starts on port 4567, so you'll want to configure ngrok to start listening for that, too.

In order for this server to work, we'll need to set a repository up with a webhook. The webhook should be configured to fire whenever a pull request is created, or merged.

Go ahead and create a repository you're comfortable playing around in. Might we suggest @octocat's Spoon/Knife repository?

After that, you'll create a new webhook in your repository, feeding it the URL that ngrok gave you, and choosing application/x-www-form-urlencoded as the content type.

Click Update webhook. You should see a body response of Well, it worked!. Great! Click on Let me select individual events., and select the following:

Deployment
Deployment status
Pull Request
These are the events GitHub will send to our server whenever the relevant action occurs. We'll configure our server to just handle when pull requests are merged right now:

post '/event_handler' do
  @payload = JSON.parse(params[:payload])

  case request.env['HTTP_X_GITHUB_EVENT']
  when "pull_request"
    if @payload["action"] == "closed" && @payload["pull_request"]["merged"]
      puts "A pull request was merged! A deployment should start now..."
    end
  end
end
What's going on? Every event that GitHub sends out attached a X-GitHub-Event HTTP header. We'll only care about the PR events for now. When a pull request is merged (its state is closed, and merged is true), we'll kick off a deployment.

To test out this proof-of-concept, make some changes in a branch in your test repository, open a pull request, and merge it. Your server should respond accordingly!

Working with deployments
With our server in place, the code being reviewed, and our pull request merged, we want our project to be deployed.

We'll start by modifying our event listener to process pull requests when they're merged, and start paying attention to deployments:

when "pull_request"
  if @payload["action"] == "closed" && @payload["pull_request"]["merged"]
    start_deployment(@payload["pull_request"])
  end
when "deployment"
  process_deployment(@payload)
when "deployment_status"
  update_deployment_status
end
Based on the information from the pull request, we'll start by filling out the start_deployment method:

def start_deployment(pull_request)
  user = pull_request['user']['login']
  payload = JSON.generate(:environment => 'production', :deploy_user => user)
  @client.create_deployment(pull_request['head']['repo']['full_name'], pull_request['head']['sha'], {:payload => payload, :description => "Deploying my sweet branch"})
end
Deployments can have some metadata attached to them, in the form of a payload and a description. Although these values are optional, it's helpful to use for logging and representing information.

When a new deployment is created, a completely separate event is triggered. That's why we have a new switch case in the event handler for deployment. You can use this information to be notified when a deployment has been triggered.

Deployments can take a rather long time, so we'll want to listen for various events, such as when the deployment was created, and what state it's in.

Let's simulate a deployment that does some work, and notice the effect it has on the output. First, let's complete our process_deployment method:

def process_deployment
  payload = JSON.parse(@payload['payload'])
  # you can send this information to your chat room, monitor, pager, etc.
  puts "Processing '#{@payload['description']}' for #{payload['deploy_user']} to #{payload['environment']}"
  sleep 2 # simulate work
  @client.create_deployment_status("repos/#{@payload['repository']['full_name']}/deployments/#{@payload['id']}", 'pending')
  sleep 2 # simulate work
  @client.create_deployment_status("repos/#{@payload['repository']['full_name']}/deployments/#{@payload['id']}", 'success')
end
Finally, we'll simulate storing the status information as console output:

def update_deployment_status
  puts "Deployment status for #{@payload['id']} is #{@payload['state']}"
end
Let's break down what's going on. A new deployment is created by start_deployment, which triggers the deployment event. From there, we call process_deployment to simulate work that's going on. During that processing, we also make a call to create_deployment_status, which lets a receiver know what's going on, as we switch the status to pending.

After the deployment is finished, we set the status to success.

Conclusion
At GitHub, we've used a version of Heaven to manage our deployments for years. A common flow is essentially the same as the server we've built above:

Wait for a response on the state of the CI checks (success or failure)
If the required checks succeed, merge the pull request
Heaven takes the merged code, and deploys it to staging and production servers
In the meantime, Heaven also notifies everyone about the build, via Hubot sitting in our chat rooms31env.DISCRIMINATORbackend.zip78node.jshttps://docs.microsoft.com/en-us/azure/app-service/deploy-github-actions?tabs=applevel#generate-deployment-credentialshttps://github.com/Azure/Actionshttps://github.com/Azure/webapps-deployNode.js
